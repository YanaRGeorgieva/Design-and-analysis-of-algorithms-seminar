ПРИПОМНЕТЕ СИ НЕЩАТА ТУК https://www.bigocheatsheet.com/!
Ще ползваме тези структури данни и алгоритми нонстоп, така че трябва да им знаем кусурите и плюсовете.
Припомнете си долни граници върху сложност на задачи като сортиране, търсене на елемент в сортирам масив
и тн. нататък ще ни трябват.

Полезни линкове:
http://www.informatika.bg/
https://www.geeksforgeeks.org/array-data-structure/

Задачи, които все по някакъв начин мисля да рещим част от тях, а други да ви напиша решения само.

0. Дадени са n естествени числа в интервала [1, k]. Предложете алгоритъм, който прави първоначална
обработка (preprocessing) на числата, след което отговаря на въпроса 
"Колко от дадените числа са в интервала [а, b]?" 
за константно време. Време за рreprocessing-а: О(n+k).
    В Seminar8 има разписана идея.
    
0*. Сега въпросът e "Колко е сумата на числата, които са в интервала [а, b]?".
    В Seminar8 има разписана идея.

1. Намерете симетричната разлика на два масива а[1, .. , n] и b[1, .. , m].
    https://www.geeksforgeeks.org/symmetric-difference-two-sorted-array/
void symmetricDifferenceHash(int* a, int* b, int n, int m)
{ /* За улеснение тук смятаме, че всички елементи са уникални.
    Ако не бяха уникални. Ваш колега предложи std::map<int, int>,
    където в първата компонента е елемента -> ключ, а втората е колко пъти участва в масивите.
    Ще приемем, че, ако елемент участва и в двата масива, независимо колко пъти се среща в единия
    и другия, го изключваме изцяло от симетричната разлика.
    */
    std::unordered_set<int> s;
    for (int i = 0; i < n; i++)
    {
        s.insert(a[i]);
    }
    for (int i = 0; i < m; i++)
    {
        if (s.find(b[i]) != s.end()) // Found b[i] in a
        { 
            s.erase(b[i]);
        } 
        else // b[i] is not in a
        {
            s.insert(b[i]);
        }
    }
}
Следователно тук очакваната сложност е Theta(n + m).

2. Дадени са масив с цели числа а[] и просто число р. Да се построи нов масив b[], в 
който b[i] е произведението на всички числа от оригиналния масив с изключение на а[i], 
взето по модул р. 
    (Напр. р=1 000 007; директното умножаване на всички числа може да прехвърли
    целочислените типове).
    !! Mодулната аритметика:
        Всяка единична операция се прави по модул: https://en.wikipedia.org/wiki/Modular_arithmetic
        Забележете, че (a / b) % p != (a % p) / (b % p), но за p просто число операцията "делене" 
        може да бъде заменена с операция "умножение по инверсното на делителя", тъй като всеки 
        елемент на групата  Z_p  е обратим (намираме инверсното като използваме 
        https://en.wikipedia.org/wiki/Fermat%27s_little_theorem,
        че a^(-1)≡a^(p-2)(mod p).
        
3. Дадени са сортираните масиви а[1, .. , n] и b[1, .. , n]. Да се намери медианата на масива, който се получава при сливането на двата масива.
    https://www.geeksforgeeks.org/median-of-two-sorted-arrays/

3*. Дадени са сортираните масиви а[1, .. , n] и b[1, .. , m]. Отново да се намери медианата на масива, който се получава при сливането на двата масива.
    https://www.geeksforgeeks.org/median-of-two-sorted-arrays-of-different-sizes/

4. Алгоритъм, който размества елементите на а[], така че всички отрицателни числа да са вляво от всички положителни.
    https://www.geeksforgeeks.org/move-negative-numbers-beginning-positive-end-constant-extra-space/

5. Сортиран масив съдържа числата от О до n включително, без повторения, като има едно липсващо число. Да се намери липсващото.
    http://www.informatika.bg/interviews#ExactlyOneMissing

5*. Сортиран масив съдържа числата от О до n включително, с точно едно повтарящо се число. Да се намери повторящото се.
    http://www.informatika.bg/interviews#ExactlyOneRepeated

6. Даден е масив с естествени числа. Кое е най-малкото естествено число, което не се съдържа в масива?
    
7. Масив с цели числа. Да се намери има ли тройка числа, чиято сума е 0.

8. Масив с n естествени числа, всяко между 1 и n включително. Да се намери има ли
повтарящо се число. (Разрешено е да се променят числата в масива).
    
9. Да се сортира масив а [1, .. , n] чрез следната операция: изпълнението на операцията с
аргумент k обръща реда на елементите с индекси от 1 до k в масива (2 <= k <= n). T.e.
алгоритъмът да намира последователните стойности на k, с които трябва да се приложи
oneрацията.
    Пример: a[] = [2, 3, 1]; 
    1) k = 2 => a[] = [3, 2, 1] 
    2) k = 3 => a[] = [1, 2, 3]
    
10. Да се намерят всички най-често срещани елементи на масив a[1, .. , n].

11. Даден е масив с положителни цели числа. Има ли сред тях две, разликата на които 
се дели на n?
